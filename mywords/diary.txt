4th May 2009, Monday

Tried out using Vi, and read up help pages for Git to familiarise with the technical terms.

This 4th May 2009 entry is modified after midnight to include the following:

How to stage change files for a commit ("git add", so as to track it for committing), how to commit changes ("git commit"), how to look at it using gitk (gitk master), how to push 'master' branch to pacific ("git push origin master"). May have "dry run" for commit through "git status", see which are the files changed - Do "git add" for relevant changes.

-commit name is a cryptographic hash (40-char hex string) of complete history up to that commit
-Files are identified by these cryptographic hashes, "object name"
-Directory stored as tree object - List of file/directory names
-Tree obj identified by hashes too
-"Git clone" assumed that you want to start working on the current branch
-"Git Remote Add" tells Git to track a remote repository, assuming you already have a current branch and do not need another one



5th May 2009, Tuesday

Its 11.37am now. What is going to happen today? Probably later going to start practising how to play with a bit of Git. But first I have to do some commits first so I can mess around in my own space. And I will create a new file listing project requirements.

When Git talks about a "clean state", working directory, index and HEAD (latest commit) agree fully

Git Reset
1) "git reset --soft" -> update HEAD, leave working directory and index alone
--> Implies slow way to say "git commit --amend" is to "git reset --soft HEAD^ && git commit"
2) "git reset --mixed" -> update HEAD, reset index, leave working directory alone
3) "git reset --hard" -> reset both index and working directory as well...

Git Rebase
e.g: git rebase -i HEAD~3

-"rebase" means to take a bunch of commits, and to try to apply the corresponding changes on top of another commit.
-With commit messages, authorship and all.
-"-i" says that it will be interactive, i.e. get to choose which commits to rebase, and in which order.
-"HEAD~3" rebase all commits descending from HEAD~3 (the great-grand-parent of HEAD) until HEAD.
-In a linear history (no merges), this means that you will rebase HEAD~2, HEAD~1 and HEAD.
-git rebase -i HEAD~3 will start text editor and present you with the list of commits to rebase.
-if you want to remove all three, you will have to add a command "noop" in the text editor.

Reverting commits and pushing local changes up...
With selected commits removed, "git push --force origin master". Need for the "--force" flag because system detects data would be lost on remote side, and by default prevents that.

Should you delete a file...
-You need it back, and its available in a previous commit
-"git checkout -- filename.txt" to get it from HEAD (current commit that has the file)...
-"git checkout HEAD^^ -- filename.txt" to get file back from previous two commits...
-Note that "--" is an optional separator



6th May 2009, Wednesday
Used "git branch newbranch HEAD^^":
Basic Meaning: Create a new branch named "newbranch" with 2nd previous commit as HEAD (root node/latest commit).

Apparently, "^" means "previous". Commit IDs and tags may be used in place of "HEAD^^".

Different branches, different states:
Editing this diary from "master" branch, not "newbranch", so "newbranch" won't have these additions 

"git checkout newbranch" switches to "newbranch"
-Added "newbranch_doc.txt"
-File appears in "newbranch" but does not appear in "master"
-When it comes to switching branches, edits made must be committed first

Back at "master" branch, "git merge newbranch"
-Combine changes from both "master" and "newbranch"
-"master" now has both diary changes and "newbranch_doc.txt"

"git branch -d newbranch" deletes "newbranch"

"git log" default to "git log HEAD"
e.g: "git log contrib/master -- .gitignore" prints log of .gitignore at contrib/master

"touch filename" command basically just updates the timestamp of a file.

./fiji runs the application... finally.

-"./fiji tests/plugin_jars.py -v" to see a list of menu entries and the plugins handling them
-once you know which plugin handles the menu entry, you can find which .jar it is in: ./fiji scripts/find-jar-for-class.py Biorad_Writer
-(replace Biorad_Writer with whatever plugin you're interested)
-once you know the .jar file, you look into the Fakefile to see if it is generated from src-plugins/ (and if yes, from which subdirectory), or from a submodule.



7th May 2009, Thursday
Compile application and its JAR files using Fakefile's configuration information.

Location information of menu items are found through plugin.config of JAR files.

With Fakefile's information, Fake.jar takes xxx.config at fiji/staged_plugins - Bundles with corresponding JAR file.

Removing JAR file from correct location removes the entire corresponding plugin.

There are plugins belonging to submodules and plugins located at fiji/src-plugins. Submodules being like plugins with source that's significant enough to live in its own git repository...

"git log -p", "git show", to show differences between commits.

Downloading of Plugins uses Timestamps and 160-bit md5.

An issue to think about though later: Plugin Manager facilitates downloading of JAR/CLASS files only, or does it facilitates downloading/compiling of source code?

With this bit of technical context understood, next will be focusing on detailed requirements gathering stage.



8th May 2009, Friday
DETAILED requirements gathering stage. Focus of research may be shifted to aimed to having an understanding of compatibility of different versions of Plugins.

Get the requirements out first!!!!

Regarding dependencies: A humble strategy I can think of is that of a second text file containing all the dependencies between different Fiji plugins, which would be downloaded each time the user wants to update Fiji plugins. Essentially, a "database" of all versions of plugins and their dependencies.

More about plugins.config: W/O this file, plugins class filenames would need to have underscore to identify it as a plugin to be picked up by Fiji. Loading classes to detect the class type would take substantial time.

A .jar file (without plugins.config) will be analyzed for plugins, and they will be installed - just enumerates the files contained, and whenever it encounters a .class file with an underscore, it assumes this is a plugin.

Dependencies are class-specific on technical level, implementation-wise is plugin-specific.

Might wanna look at fake/Fake.java's ByteCodeAnalyzer class.



9th May 2009, Saturday
I've noticed that having the same menu item name will have Fiji application generating an error, even if they are on different menu section.

Removing plugin menu item doesn't seem to work...

I put up a more comprehensive detailed requirements with breakdown of tasks... Waiting to establish requirements...

Description of available plugins should be a task as well.

Think in terms of files (JAR and CLASS), not in terms of plugins... To be elaborated...



10th May 2009, Sunday
Tried writing a plugin using JSwing... Seemed to work.



11th May 2009, Monday
Tried out HTMLEditorKit, get a feel of the workload and effort needed.



12th May 2009, Tuesday
Rough design sketches to get an idea.

"git cherry-pick contrib/plugin-manager" - takes a commit as an argument, and then tries to re-apply the changes that commit introduced on top of the current HEAD. If that succeeds, it takes the author information as well as the commit messages and creates a new commit from all that.

"git show HEAD" to see the changes, commit message.



13th May 2009, Wednesday
Finalizing (more or less?) detailed requirements, know my users a little more.

Soon, time will come for class design...



14th May 2009, Thursday
After starting "git log", hit the Return key.
Output of "git log" is piped into the so-called pager, a program with the name "less.exe". Sole purpose of a pager is to take the output of another program and to present it to the user. Makes it possible to scroll up and down, with PageUp/PageDown (or CursorUp/CursorDown).

Made a class diagram.



15th-19th May 2009, Fri-Tue
Hmmm.... Its been a while. Have been trying to debug my interface. A list of these classes is more or less confirmed and partially implemented:
PluginManager.java - The main UI that uses Controller
TextPaneFormat.java - Utility for text formatting in a textpane
Controller.java - In charge of determining dependencies, getting data from the plugin files, in short the lower level implementation
Dependency.java - Data form of a dependency
PluginObject.java - Data form of a Plugin, already "processed and ready to use"

Keep in mind:
-Have explicit import e.g "import ij.gui.ImageCanvas;" not implicit like "import ij.gui.*;"
-Have empty lines between methods, and even inside methods between logical blocks
-Have lowercase for packages
-Have expressive names for methods and classes and objects
-use Java 1.5-style generics, e.g.: List<String> = new LinkedList<String>();



20th May 2009, Wednesday
New Design: Basically plugin has two statuses. Either plugin is uninstalled or its installed. If its uninstalled, users can choose to remain as it is ("Uninstalled") or "Install" it. If its installed, users can choose to remain as it is ("Installed") or "Remove" it.

Suggestion for better usability: Make the "Install" and "Remove" labels bold, and update the label of the action button to say something like "Install 3, Remove 2", and grey it out when the user did not specify any changes.

New design is partially implemented. Looks simpler now... I only hope coding the rest of the interface doesn't get complicated.

To do NEXT:
1) Remote database, a version with artificial information for testing purposes, including information for UPDATED plugins.
2) Able to view the plugins, installed, uninstalled, along with can-be-updated
3) Put up the rest of the interface elements



21st May 2009, Thursday
My progress so far: Able to list out plugins in different categories. Now to wait for further establishment of design requirements...



22nd May 2009, Friday
There seems to be some discrepancy between the results of my Fiji Plugin Manager and the Fiji Updater... To be updated in a while.



23rd May 2009, Saturday
-Bug fix of pluginTableModel
-Now able to display same output as that of old Fiji Updater
-Text format change

Something unnerving...
When processing plugin file data:
When digest is null compared to remoteDigest, it means local plugin does not exist ==> Install
When date is null, it means local plugin should be updated? Why? How is it even null in the first place (When corresponding digest is NOT null)?
And we are using almost exactly the same code as Fiji Updater here.

I need a break...

Anyway... Official coding starts on Monday! (23rd May actually)



25th May, Monday

1) Fiji Updater Bug discovered. Null date value is due to wrong input of path key value when creating the Dates map object.
2) Implemented TableCellRenderer - You are now able to change format of text in a table
3) Implementation of adding (i.e: Downloading) of plugins is complete.

Fiji Updater intended algorithm is:

For each plugin file:
-Same digest ==> Don't consider for update
-Newer date on local than on server ==> Don't consider for update (?!)
-Local digest is null when using server side's filename ==> Uninstalled
-Otherwise it is an existing local plugin requiring update

REMINDER: Looks quite standalone in its problem. But remember to go back and understand the conceptual model of the Fiji Updater...

Removal/Uninstallation of Plugins to be considered later on.

What's planned:
First task: Implement progressbar-style window for plugin downloads.
Second task: Refactoring - Bring out a new utility class from PluginDataReader
Third task: Re-enable mock database again - Plugin Dependencies to work on (IOW actual downloading is disabled here)

Above tasks hopefully should take less than 10 working days.

Other tasks not in line yet
-Fiji Updater conceptual model... What should it exactly do?!
-Non-core features like e.g: 3rd party support, CLASS support
-Removal/Uninstallation of plugins
-Gathering of plugin information (Description and dependencies)
-Construction of Database (Wait till we have a clue what information goes in there)



26th May, Tuesday

Going into details for Refactoring (What's left undone):

Code readability issues
-Avoid distraction of initialization of variables - Unless its an important note
-Avoid using unnecessary "this." statement
-super()... Unnecessary?

Structural issues
-Make a JFrame that implements PlugIn
-Use Layout
-Merge TextPaneFormat with PluginManager?
-the old insertText() of TextPaneFormat
   Split into something like:
      insertTitle(text)
      insertText(text, param) //if you want italics/bold
      insertText(text) //if you want default

What's done:
Still on getting out a working progressbar. Have been thinking too much about design patterns.

NOTE this should get you the size of a file:
new URL(baseURL, fileName + suffix).openConnection().getContentLength();



27th May, Wednesday

Because of a stupid mistake I made with Git while trying to merge conflicts, now I have to redo some stuff. At least I got the algorithm of it in my head...

Download now appears to work...