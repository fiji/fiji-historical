4th May 2009, Monday

Tried out using Vi, and read up help pages for Git to familiarise with the technical terms.

This 4th May 2009 entry is modified after midnight to include the following:

How to stage change files for a commit ("git add", so as to track it for committing), how to commit changes ("git commit"), how to look at it using gitk (gitk master), how to push 'master' branch to pacific ("git push origin master"). May have "dry run" for commit through "git status", see which are the files changed - Do "git add" for relevant changes.

-commit name is a cryptographic hash (40-char hex string) of complete history up to that commit
-Files are identified by these cryptographic hashes, "object name"
-Directory stored as tree object - List of file/directory names
-Tree obj identified by hashes too
-"Git clone" assumed that you want to start working on the current branch
-"Git Remote Add" tells Git to track a remote repository, assuming you already have a current branch and do not need another one



5th May 2009, Tuesday

Its 11.37am now. What is going to happen today? Probably later going to start practising how to play with a bit of Git. But first I have to do some commits first so I can mess around in my own space. And I will create a new file listing project requirements.

When Git talks about a "clean state", working directory, index and HEAD (latest commit) agree fully

Git Reset
1) "git reset --soft" -> update HEAD, leave working directory and index alone
--> Implies slow way to say "git commit --amend" is to "git reset --soft HEAD^ && git commit"
2) "git reset --mixed" -> update HEAD, reset index, leave working directory alone
3) "git reset --hard" -> reset both index and working directory as well...

Git Rebase
e.g: git rebase -i HEAD~3

-"rebase" means to take a bunch of commits, and to try to apply the corresponding changes on top of another commit.
-With commit messages, authorship and all.
-"-i" says that it will be interactive, i.e. get to choose which commits to rebase, and in which order.
-"HEAD~3" rebase all commits descending from HEAD~3 (the great-grand-parent of HEAD) until HEAD.
-In a linear history (no merges), this means that you will rebase HEAD~2, HEAD~1 and HEAD.
-git rebase -i HEAD~3 will start text editor and present you with the list of commits to rebase.
-if you want to remove all three, you will have to add a command "noop" in the text editor.

Reverting commits and pushing local changes up...
With selected commits removed, "git push --force origin master". Need for the "--force" flag because system detects data would be lost on remote side, and by default prevents that.

Should you delete a file...
-You need it back, and its available in a previous commit
-"git checkout -- filename.txt" to get it from HEAD (current commit that has the file)...
-"git checkout HEAD^^ -- filename.txt" to get file back from previous two commits...
-Note that "--" is an optional separator



6th May 2009, Wednesday
Used "git branch newbranch HEAD^^":
Basic Meaning: Create a new branch named "newbranch" with 2nd previous commit as HEAD (root node/latest commit).

Apparently, "^" means "previous". Commit IDs and tags may be used in place of "HEAD^^".

Different branches, different states:
Editing this diary from "master" branch, not "newbranch", so "newbranch" won't have these additions 

"git checkout newbranch" switches to "newbranch"
-Added "newbranch_doc.txt"
-File appears in "newbranch" but does not appear in "master"
-When it comes to switching branches, edits made must be committed first

Back at "master" branch, "git merge newbranch"
-Combine changes from both "master" and "newbranch"
-"master" now has both diary changes and "newbranch_doc.txt"

"git branch -d newbranch" deletes "newbranch"

"git log" default to "git log HEAD"
e.g: "git log contrib/master -- .gitignore" prints log of .gitignore at contrib/master

"touch filename" command basically just updates the timestamp of a file.

./fiji runs the application... finally.

-"./fiji tests/plugin_jars.py -v" to see a list of menu entries and the plugins handling them
-once you know which plugin handles the menu entry, you can find which .jar it is in: ./fiji scripts/find-jar-for-class.py Biorad_Writer
-(replace Biorad_Writer with whatever plugin you're interested)
-once you know the .jar file, you look into the Fakefile to see if it is generated from src-plugins/ (and if yes, from which subdirectory), or from a submodule.



7th May 2009, Thursday
Compile application and its JAR files using Fakefile's configuration information.

Location information of menu items are found through plugin.config of JAR files.

With Fakefile's information, Fake.jar takes xxx.config at fiji/staged_plugins - Bundles with corresponding JAR file.

Removing JAR file from correct location removes the entire corresponding plugin.

There are plugins belonging to submodules and plugins located at fiji/src-plugins. Submodules being like plugins with source that's significant enough to live in its own git repository...

"git log -p", "git show", to show differences between commits.

Downloading of Plugins uses Timestamps and 160-bit md5.

An issue to think about though later: Plugin Manager facilitates downloading of JAR/CLASS files only, or does it facilitates downloading/compiling of source code?

With this bit of technical context understood, next will be focusing on detailed requirements gathering stage.



8th May 2009, Friday
DETAILED requirements gathering stage. Focus of research may be shifted to aimed to having an understanding of compatibility of different versions of Plugins.

Get the requirements out first!!!!

Regarding dependencies: A humble strategy I can think of is that of a second text file containing all the dependencies between different Fiji plugins, which would be downloaded each time the user wants to update Fiji plugins. Essentially, a "database" of all versions of plugins and their dependencies.

More about plugins.config: W/O this file, plugins class filenames would need to have underscore to identify it as a plugin to be picked up by Fiji. Loading classes to detect the class type would take substantial time.

A .jar file (without plugins.config) will be analyzed for plugins, and they will be installed - just enumerates the files contained, and whenever it encounters a .class file with an underscore, it assumes this is a plugin.

Dependencies are class-specific on technical level, implementation-wise is plugin-specific.

Might wanna look at fake/Fake.java's ByteCodeAnalyzer class.



9th May 2009, Saturday
I've noticed that having the same menu item name will have Fiji application generating an error, even if they are on different menu section.

Removing plugin menu item doesn't seem to work...

I put up a more comprehensive detailed requirements with breakdown of tasks... Waiting to establish requirements...

Description of available plugins should be a task as well.

Think in terms of files (JAR and CLASS), not in terms of plugins... To be elaborated...



10th May 2009, Sunday
Tried writing a plugin using JSwing... Seemed to work.



11th May 2009, Monday
Tried out HTMLEditorKit, get a feel of the workload and effort needed.



12th May 2009, Tuesday
Rough design sketches to get an idea.

"git cherry-pick contrib/plugin-manager" - takes a commit as an argument, and then tries to re-apply the changes that commit introduced on top of the current HEAD. If that succeeds, it takes the author information as well as the commit messages and creates a new commit from all that.

"git show HEAD" to see the changes, commit message.



13th May 2009, Wednesday
Finalizing (more or less?) detailed requirements, know my users a little more.

Soon, time will come for class design...