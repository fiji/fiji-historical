4th May 2009, Monday

Tried out using Vi, and read up help pages for Git to familiarise with the technical terms.

This 4th May 2009 entry is modified after midnight to include the following:

How to stage change files for a commit ("git add", so as to track it for committing), how to commit changes ("git commit"), how to look at it using gitk (gitk master), how to push 'master' branch to pacific ("git push origin master"). May have "dry run" for commit through "git status", see which are the files changed - Do "git add" for relevant changes.

-commit name is a cryptographic hash (40-char hex string) of complete history up to that commit
-Files are identified by these cryptographic hashes, "object name"
-Directory stored as tree object - List of file/directory names
-Tree obj identified by hashes too
-"Git clone" assumed that you want to start working on the current branch
-"Git Remote Add" tells Git to track a remote repository, assuming you already have a current branch and do not need another one



5th May 2009, Tuesday

Its 11.37am now. What is going to happen today? Probably later going to start practising how to play with a bit of Git. But first I have to do some commits first so I can mess around in my own space. And I will create a new file listing project requirements.

When Git talks about a "clean state", working directory, index and HEAD (latest commit) agree fully

Git Reset
1) "git reset --soft" -> update HEAD, leave working directory and index alone
--> Implies slow way to say "git commit --amend" is to "git reset --soft HEAD^ && git commit"
2) "git reset --mixed" -> update HEAD, reset index, leave working directory alone
3) "git reset --hard" -> reset both index and working directory as well...

Git Rebase
e.g: git rebase -i HEAD~3

-"rebase" means to take a bunch of commits, and to try to apply the corresponding changes on top of another commit.
-With commit messages, authorship and all.
-"-i" says that it will be interactive, i.e. get to choose which commits to rebase, and in which order.
-"HEAD~3" rebase all commits descending from HEAD~3 (the great-grand-parent of HEAD) until HEAD.
-In a linear history (no merges), this means that you will rebase HEAD~2, HEAD~1 and HEAD.
-git rebase -i HEAD~3 will start text editor and present you with the list of commits to rebase.
-if you want to remove all three, you will have to add a command "noop" in the text editor.

Reverting commits and pushing local changes up...
With selected commits removed, "git push --force origin master". Need for the "--force" flag because system detects data would be lost on remote side, and by default prevents that.

Should you delete a file...
-You need it back, and its available in a previous commit
-"git checkout -- filename.txt" to get it from HEAD (current commit that has the file)...
-"git checkout HEAD^^ -- filename.txt" to get file back from previous two commits...
-Note that "--" is an optional separator



6th May 2009, Wednesday
Used "git branch newbranch HEAD^^":
Basic Meaning: Create a new branch named "newbranch" with 2nd previous commit as HEAD (root node/latest commit).

Apparently, "^" means "previous". Commit IDs and tags may be used in place of "HEAD^^".

Different branches, different states:
Editing this diary from "master" branch, not "newbranch", so "newbranch" won't have these additions 

"git checkout newbranch" switches to "newbranch"
-Added "newbranch_doc.txt"
-File appears in "newbranch" but does not appear in "master"
-When it comes to switching branches, edits made must be committed first

Back at "master" branch, "git merge newbranch"
-Combine changes from both "master" and "newbranch"
-"master" now has both diary changes and "newbranch_doc.txt"

"git branch -d newbranch" deletes "newbranch"

"git log" default to "git log HEAD"
e.g: "git log contrib/master -- .gitignore" prints log of .gitignore at contrib/master

"touch filename" command basically just updates the timestamp of a file.

./fiji runs the application... finally.

-"./fiji tests/plugin_jars.py -v" to see a list of menu entries and the plugins handling them
-once you know which plugin handles the menu entry, you can find which .jar it is in: ./fiji scripts/find-jar-for-class.py Biorad_Writer
-(replace Biorad_Writer with whatever plugin you're interested)
-once you know the .jar file, you look into the Fakefile to see if it is generated from src-plugins/ (and if yes, from which subdirectory), or from a submodule.



7th May 2009, Thursday
Compile application and its JAR files using Fakefile's configuration information.

Location information of menu items are found through plugin.config of JAR files.

With Fakefile's information, Fake.jar takes xxx.config at fiji/staged_plugins - Bundles with corresponding JAR file.

Removing JAR file from correct location removes the entire corresponding plugin.

There are plugins belonging to submodules and plugins located at fiji/src-plugins. Submodules being like plugins with source that's significant enough to live in its own git repository...

"git log -p", "git show", to show differences between commits.

Downloading of Plugins uses Timestamps and 160-bit md5.

An issue to think about though later: Plugin Manager facilitates downloading of JAR/CLASS files only, or does it facilitates downloading/compiling of source code?

With this bit of technical context understood, next will be focusing on detailed requirements gathering stage.



8th May 2009, Friday
DETAILED requirements gathering stage. Focus of research may be shifted to aimed to having an understanding of compatibility of different versions of Plugins.

Get the requirements out first!!!!

Regarding dependencies: A humble strategy I can think of is that of a second text file containing all the dependencies between different Fiji plugins, which would be downloaded each time the user wants to update Fiji plugins. Essentially, a "database" of all versions of plugins and their dependencies.

More about plugins.config: W/O this file, plugins class filenames would need to have underscore to identify it as a plugin to be picked up by Fiji. Loading classes to detect the class type would take substantial time.

A .jar file (without plugins.config) will be analyzed for plugins, and they will be installed - just enumerates the files contained, and whenever it encounters a .class file with an underscore, it assumes this is a plugin.

Dependencies are class-specific on technical level, implementation-wise is plugin-specific.

Might wanna look at fake/Fake.java's ByteCodeAnalyzer class.



9th May 2009, Saturday
I've noticed that having the same menu item name will have Fiji application generating an error, even if they are on different menu section.

Removing plugin menu item doesn't seem to work...

I put up a more comprehensive detailed requirements with breakdown of tasks... Waiting to establish requirements...

Description of available plugins should be a task as well.

Think in terms of files (JAR and CLASS), not in terms of plugins... To be elaborated...



10th May 2009, Sunday
Tried writing a plugin using JSwing... Seemed to work.



11th May 2009, Monday
Tried out HTMLEditorKit, get a feel of the workload and effort needed.



12th May 2009, Tuesday
Rough design sketches to get an idea.

"git cherry-pick contrib/plugin-manager" - takes a commit as an argument, and then tries to re-apply the changes that commit introduced on top of the current HEAD. If that succeeds, it takes the author information as well as the commit messages and creates a new commit from all that.

"git show HEAD" to see the changes, commit message.



13th May 2009, Wednesday
Finalizing (more or less?) detailed requirements, know my users a little more.

Soon, time will come for class design...



14th May 2009, Thursday
After starting "git log", hit the Return key.
Output of "git log" is piped into the so-called pager, a program with the name "less.exe". Sole purpose of a pager is to take the output of another program and to present it to the user. Makes it possible to scroll up and down, with PageUp/PageDown (or CursorUp/CursorDown).

Made a class diagram.



15th-19th May 2009, Fri-Tue
Hmmm.... Its been a while. Have been trying to debug my interface. A list of these classes is more or less confirmed and partially implemented:
PluginManager.java - The main UI that uses Controller
TextPaneFormat.java - Utility for text formatting in a textpane
Controller.java - In charge of determining dependencies, getting data from the plugin files, in short the lower level implementation
Dependency.java - Data form of a dependency
PluginObject.java - Data form of a Plugin, already "processed and ready to use"

Keep in mind:
-Have explicit import e.g "import ij.gui.ImageCanvas;" not implicit like "import ij.gui.*;"
-Have empty lines between methods, and even inside methods between logical blocks
-Have lowercase for packages
-Have expressive names for methods and classes and objects
-use Java 1.5-style generics, e.g.: List<String> = new LinkedList<String>();



20th May 2009, Wednesday
New Design: Basically plugin has two statuses. Either plugin is uninstalled or its installed. If its uninstalled, users can choose to remain as it is ("Uninstalled") or "Install" it. If its installed, users can choose to remain as it is ("Installed") or "Remove" it.

Suggestion for better usability: Make the "Install" and "Remove" labels bold, and update the label of the action button to say something like "Install 3, Remove 2", and grey it out when the user did not specify any changes.

New design is partially implemented. Looks simpler now... I only hope coding the rest of the interface doesn't get complicated.

To do NEXT:
1) Remote database, a version with artificial information for testing purposes, including information for UPDATED plugins.
2) Able to view the plugins, installed, uninstalled, along with can-be-updated
3) Put up the rest of the interface elements



21st May 2009, Thursday
My progress so far: Able to list out plugins in different categories. Now to wait for further establishment of design requirements...



22nd May 2009, Friday
There seems to be some discrepancy between the results of my Fiji Plugin Manager and the Fiji Updater... To be updated in a while.



23rd May 2009, Saturday
-Bug fix of pluginTableModel
-Now able to display same output as that of old Fiji Updater
-Text format change

Something unnerving...
When processing plugin file data:
When digest is null compared to remoteDigest, it means local plugin does not exist ==> Install
When date is null, it means local plugin should be updated? Why? How is it even null in the first place (When corresponding digest is NOT null)?
And we are using almost exactly the same code as Fiji Updater here.

I need a break...

Anyway... Official coding starts on Monday! (23rd May actually)



25th May, Monday

1) Fiji Updater Bug discovered. Null date value is due to wrong input of path key value when creating the Dates map object.
2) Implemented TableCellRenderer - You are now able to change format of text in a table
3) Implementation of adding (i.e: Downloading) of plugins is complete.

Fiji Updater intended algorithm is:

For each plugin file:
-Same digest ==> Don't consider for update
-Newer date on local than on server ==> Don't consider for update (?!)
-Local digest is null when using server side's filename ==> Uninstalled
-Otherwise it is an existing local plugin requiring update

REMINDER: Looks quite standalone in its problem. But remember to go back and understand the conceptual model of the Fiji Updater...

Removal/Uninstallation of Plugins to be considered later on.

What's planned:
First task: Implement progressbar-style window for plugin downloads.
Second task: Refactoring - Bring out a new utility class from PluginDataReader
Third task: Re-enable mock database again - Plugin Dependencies to work on (IOW actual downloading is disabled here)

Above tasks hopefully should take less than 10 working days.

Other tasks not in line yet
-Fiji Updater conceptual model... What should it exactly do?!
-Non-core features like e.g: 3rd party support, CLASS support
-Removal/Uninstallation of plugins
-Gathering of plugin information (Description and dependencies)
-Construction of Database (Wait till we have a clue what information goes in there)



26th May, Tuesday

Going into details for Refactoring (What's left undone):

Code readability issues
-Avoid distraction of initialization of variables - Unless its an important note
-Avoid using unnecessary "this." statement
-super()... Unnecessary?

Structural issues
-Make a JFrame that implements PlugIn
-Use Layout
-Merge TextPaneFormat with PluginManager?
-the old insertText() of TextPaneFormat
   Split into something like:
      insertTitle(text)
      insertText(text, param) //if you want italics/bold
      insertText(text) //if you want default

What's done:
Still on getting out a working progressbar. Have been thinking too much about design patterns.

NOTE this should get you the size of a file:
new URL(baseURL, fileName + suffix).openConnection().getContentLength();



27th May, Wednesday

Because of a stupid mistake I made with Git while trying to merge conflicts, now I have to redo some stuff. At least I got the algorithm of it in my head...

Download now appears to work...



28-29th May, Thu-Fri

At last!
What was implemented:
-JFrame that implements PlugIn for PluginManager.java
-Layout Manager for PluginManager.java frame
-TextPaneFormat more logically, merged with PluginManager.java
-Download Manager works: Able to download selected files
-Refactoring: New PluginDataProcessor.java
-Stick to basic programming conventions

To do soon (Planned in order):
1-Refactoring stage 4: Change of JTableX and RowEditorModel into implementation of TableColumnModel instead
2-Display download/time manager for downloading of current.txt and/or calculating md5 sums
3-Work on Dependencies checking for Controller.java
4-Able to delete incomplete files when download manager is cancelled
5-Have a Layout Manager for DownloadUI too?
6-Provide brief descriptions

Estimated time to do the above tasks:
Having learnt my lesson, I think task 1-4 will take me five days (Mon to Friday).

Current plans: The "database" would be expanded from current.txt, including dependencies and filesize (To avoid making too many connections at a time just to get download size for our Download Manager). A separate database would contain richer information like description.



1st-2nd June, Monday-Tuesday
What was implemented:
-Refactoring stage 4: A new PluginTable that replaces JTableX and RowEditorModel, simpler code
-Controller.java now has a basic check for dependencies when adding plugins - System.out.println output only

Through discussion:
- Most of the code regarding the table (settings and the like) should be at the definition of PluginTable
- Table will handle the PluginList directly, instead of leaving the latter to its attributes
- Current problem: PluginTable is not told anything about the plugins, and the selection mode is not specified by PluginTable
- Problems to take note of, intuitiveness: PluginCollection and PluginDataReader, which one should text parsing go to?



3rd June, Wednesday
-PluginTable class now in charge of PluginTableModel and its own settings after been handed the Controller and PluginManager references.
-addDependency() of Controller class works by adding ALL dependencies related to a particular plugin.
-getUnlistedInstalls(), getUnlistedUpdates() which generates a list of dependencies that the user did NOT visibly select to install/update.
-Test cases for Dependency-checking created. Having went through them, addDependency() at this stage should be considered bug-free.

Revised implementation tasklist from Thursday to Friday, in order:
1-Writing method for removeDependent() for Controller class
2-Display download/time manager for downloading of current.txt and or calculating md5 sums
3-PluginCollection and PluginDataReader refactoring
4-Able to delete incomplete files when download manager is cancelled
5-Have a Layout Manager for DownloadUI
6-Further improve coding conventions

Knowing my coding abilities at this stage, probably hard to complete all tasks...



4th June, Thursday
-removeDependent() for Controller class implemented
   -The algorithm for removal seemed more straightforward than that of adding. Weird.
-Refactored Installer.java by having additional Downloader.java
-Refactored PluginDataReader.java with a new class LoadStatusDisplay inside
   -Separation of presentation from content using Observer pattern

Alas... Still need to implement the presentation when it comes to download current.txt

What remains a mystery...

"How the DataReader knows so fully well how to parse a text file into a plugin list, while the PluginCollection does not" - I thought PluginCollection is just a collection of plugins, while the DataReader's responsibility is to "read data", which parsing text file is considered part of?

For PluginCollection:
"make an inner class that implements Iterator<PluginObject> and that knows how to filter by a multitude of parameters."

"Perhaps an inner interface 'Filter' (not 'PluginFilter', as we know already that this is all about plugins) would just have one method: boolean matchesFilter(PluginObject plugin)"

Wait? What is meant by filter? Is it by giving a PluginCollection method (Just one method) some parameters which would then loop through the list and selects a new list that fits the requirements stated by the parameters? I don't quite get matchesFilter() suggestion either. Why filter by plugin when I thought all these while I'm filtering by PluginObject.STATUS_INSTALLED and the like?



5th June, Friday
Display status when loading
- Downloader.java modified to create new Connection after its constructors are called - So that filesize can be retrieved as a method
- PluginDataReader.java now allow displaying download status of current.txt.
- LoadStatusDisplay now observes PluginDataReader, which in turn observes Downloader.

Refactoring
- PluginCollection now implements "Filter" pattern
- Use Iterator when able to (Installer class)
- Clean up clode (and improve coding conventions)

Tasks pushed to next week:
- Delete incomplete files when download manager is cancelled ==> Still work to be done
- Have a layout manager for DownloadUI

Problems: Tried cancelling downloads, but even after interrupting the thread, the download continues!

Tasks for next week:
- Have a layout manager for Download UI
- Resolve the weird issue of continuing downloads of course
- Continue Dependency-checking for Controller.java ==> Presentation issues ==> How to present the information? Implement.
- Start going into thinking up of and developing the database



8th June, Monday
Completed:
- Layout Manager for Download UI.
- Cancelling of download issues resolved - Thread.interrupt() doesn't work, tracking null reference to Thread is used instead
- Refactored Downloader.java. Allowed for finer control.
- Refactored PluginDataProcessor.java to have a new getSavePath(String saveDirectory, String pluginName) to avoid repeating code inside Installer.java

Future:
In lieu of construction and reading of a database file (In order to get plugin description, timestamps, dependencies and perhaps filesize?), I anticipate further reworking on PluginDataReader:
- 1st Step: DOWNLOAD current.txt and/or remote DB
- 2nd Step: Initialize, get information from local plugins (Currently that's the first step)
     - STORE digest of each file in TreeMap
     - READ the DB file
     - For each file,
        - if (digest == DB's digest) STORE timestamp of file from DB in TreeMap
     - If digest is not found at DB, get timestamp from file itself, STORE in TreeMap
     - Note: You may want to look into splitting "getDigestAndDateFromFile()" into two separate func in PluginDataProcessor
- 3rd Step: Read current.txt to STORE latest digest and latest timestamp in TreeMaps
- 4th Step: Convert to PluginObjects....

Past considerations: Problems with using PluginObjects themselves as Dependency references
- PluginObjects are defined as ONE instance for each Plugin with NO regards to version, only additional update info if any
- Dependencies may be based on different versions of a Plugin - Problematic to identify the actual instance used for display
- If we force only one instance per Plugin, displaying actual dependencies' md5 sums and dates require additional attributes, doubly so if any updates
- In the case of a dependency where there already exists a newer version of a Plugin, information like Plugin Description becomes redundant (Two existing instances of the same Plugin)

I think its best to stick to the old use of Dependency object.



9th June, Tuesday
Completed:
- Dependency-information gathering is refined. Able to detect the very first plugin that was called by the method and add it to the preliminary lists.
- Conflicts detection done. Display done.
- Refactored Controller.java, PluginCollection.java, and PluginManager.java to keep to the spirit of "DRY".
   ==> Repeating code now changed to use of a "Filter"

Next tasks to consider:
- Refactoring TextPaneFormat and PluginManager... "DRY" principle still applies...
- Refactoring to have a simpler "for (PluginObject myPlugin : change_removeList)" when possible
- best if PluginObject can have methods like isInstallable(), isDeletable()
- Actual interface display of plugin dependency check



10th June, Wednesday
Completed:
- Refactored TextPaneFormat inside PluginManager: New insertDependenciesList method to cater to multiple use of listing dependencies of a plugin
- Refactored mainly PluginCollection, Controller, PluginObject
   ==> Simplify code reading through the use of "for (PluginObject plugin : pluginList)"
   ==> PluginObject now has new methods like isInstallable(), toUpdate(), and so on
   ==> Thus further simplify reading of the code, without needing to read longer lines like plugin.getStatus() == PluginObject.STATUS_INSTALLED
- Researched use of Java XPath API: It certainly makes it more convenient to parse XML data
   ==> Sample XML file and test class has been created

Core features of Plugin Manager remaining to be implemented so far
- Actual interface display of displaying plugin dependencies and conflicts
- XML database and their (placeholder!) contents
- List by search term: Search by filename or by description? ==> Requires refining of this point
- Removal of plugins
- Unaddressed point: What application should do when download/removal of plugin is finished????
- 3rd party plugins' support

Regarding CLASS plugins
==> Location at run-time is fixed
==> It should be safe to assume that Fiji won't introduce CLASS plugins to current.txt?
==> If so, they belong to 3rd party plugins category



11th June, Thursday
Tasks I did today:
- Minor improvements to the UI of PluginManager.java
   ==> Button text changed, enabling/disabling at appropriate times, text content scrolling issues.
- The UI displaying conflicts and dependencies has been implemented
   ==> Implemented the feature to download plugins upon clicking "Confirmation" button
   ==> (Although not tested yet since its still using artificial plugins)
- XML file's content structure... Modified a little
   ==> May need further modification to make it easier for coding purposes (And might make it more readable too)
   ==> Or maybe not...

Upon a second look:
- I could first call "//plugin/attribute::filename"
- Use the list of names generated to loop and get each version through calling "//plugin[@filename='" + filename + "']/version/timestamp/text()".
- Use the list of timestamps (versions) generated to retrieve the data as and when needed.
- For example "//plugin[@filename='" + filename + "']/version[timestamp='" + timestamp + "']/files/dependency/*/text()" to get all dependency information of a stated version of a stated plugin.



12th June, Friday
Tasks completed:
- Displayed XML data (Plugin information) in a logical manner using TempTestXML.java

Regarding rework on PluginDataReader (New version):
- 1st Step: DOWNLOAD the XML file
- 2nd Step: Initialize, get information from local plugins (Currently that's the first step)
     - STORE digest of each local file in "local" TreeMap
     - READ the XML file
     - For each plugin in XML file
        - Get latest timestamps
        - STORE latest timestamp, and corresponding digests in "remote" TreeMaps
     - For each local file,
        - if (digest == XML list's digest) STORE XML list's retrieved timestamp in "local" TreeMap
     - If digest is not found at DB, get timestamp from file itself, STORE in "local" TreeMap
     - Note: You may want to look into splitting "getDigestAndDateFromFile()" into two separate func in PluginDataProcessor
- 3rd Step: Convert to PluginObjects....

Tasks for next week:
- Minor UI modification for PluginManager UI: Implement arrow keys
- Implement that above algorithm (w/ placeholder code)
- Plugin Manager: List by search term (Search by filename or by description?)

I think I'll have to start writing some plugin information and save as an XML file for testing purposes.



15th June, Monday
Tasks Completed:
- Implementation of arrow keys of PluginManager UI: Frustratingly failed
   ==> (Though its sort of implemented by default, just not the way required).
   ==> How to listen for the event where the text is _clicked_ where an individual component in a row is selected?
- Listing by search term: Both filename and by description. Somewhat crude though, but easily expandable (I hope).
- Artificial testing XML file created (Belongs in pluginInfo folder)

Work in progress: 
- XML Parsing.



16th June, Tuesday
Tasks Completed:
- XMLFileReader parses & returns appropriate information as requested by PluginDataReader.
   ==> Works for the artificial list of plugins
   ==> *Should* work for real actual plugins (Not tested yet)
- pluginObject expanded to include newDescription, filesize and newFilesize
- Instead of that temporary "simulation", calculation of filesize replaced it (Which requires those filesize/newFilesize integer attributes)
- Able to check XML document for validation (DTD), if not valid, application does not load.



17th June, Wednesday
Tasks Completed:
- Worked out that in PluginDataReader should throw Error objects to the PluginManager UI, where the UI will handle the presentation of the error
   ==> Shouldn't be occurring anyway as any error will render application unable to run properly.
- New UI Class: RecordsBuilderUI.java
   ==> User Interface of editing and uploading plugins (And selecting which one to do too)

Algorithm for editing:
- Developer wants to edit and upload plugin(s)
   ==> Takes action.
- Loading RecordsBuilderUI
   ==> plugin information generated from LOCAL side
- Interface of RecordsBuilderUI displayed, list of plugins shown
- Developer deselects/selects plugin(s) to upload
   ==> PluginObject removed/added from a special list
- Developer chooses to edit description
   ==> PluginObject's description attribute will be edited
- Developer chooses to upload plugin(s)
   ==> Upload the plugins in the special list (Do we generate an updated current.xml/current.txt as well?)



18th-19th June, Thursday-Friday
Tasks Completed:
- PluginManager UI is now "merged" wih RecordsBuilderUI: Both share the same interface, having user and developer version.
- Created a new "Upload" option on ComboBoxes for the Developer version of the UI.
- Able to edit description text for "Upload-able" Plugins: A new status and action created for the PluginObject.
- Created placeholder classes: DependencyAnalyzer & Uploader

Next Immediate Work to take on:
- Refactor XMLFileBuilder?
- Developer verison: After clicking on "Upload" button, upload data to server

What these data to upload to server consists of:
- They are plugins that are "uploadable" and are set to "Upload"
- Additional new plugin information inserted into XML document
- Upload new XML document along with the required plugins to server

Incremental tasks (In order):
1.) Refactor XMLFileBuilder (?) ==> Look into SAX I guess...

2.) Convert ByteCodeAnalyzer (From Fake.java) into a Dependency Analyzer class.
3.) For starters, DependencyAnayzer.java should be used on selected Plugins after "Upload" button is clicked.
4.) You need REAL plugins to test this...

5.) Inserting updated plugin data in XML document and current.txt format.
6.) Refer to old Fiji_Updater, how to upload plugins
7.) Perhaps refer to old Fiji_Updater... On how to upload a new current.txt (?)
8.) I'd have to ask for permission to test uploading?

Note: For developer version, database of plugins at the remote side should be locked when he starts the Plugin Manager, the lock is to be released only after developer stops using.

2nd Note: For the developer version, it appears that implementation is best to calculate the dependencies of "Uploadable Fiji Plugins" (isFijiPlugin() && isUploadable()) after the user clicks to Install/Remove/Upload, and for the case of Install/Remove, that's before Controller gets its hands on these plugins. Just for future note.



22nd June, Monday
Tasks Completed:
- XMLFileBuilder's implementation changed from XPath to that of SAX...
- Refactored DownloadUI.java - Unnecessary, unreachable blocks of code removed

Next task: Remove global stuff, convert TextPaneFormat into TextPaneDisplay (Extension of JTextPane)



23rd June, Tuesday
Tasks Completed:
- Code Refactor: Oh well, did the best I could in attempting to simplify the logic
   ==> Moved methods to different classes, removed any redundant, unreachable code
   ==> Renamed methods, classes to more appropriate ones (e.g.: PluginDataReader to PluginListBuilder, since that's what it is about anyway)
   ==> In particular, reduced repeating code at Controller
- Developer version is able to select to view "Uploadable plugins only"



24th-25th June, Wednesday-Thursday
Tasks Completed:
- Implemented DependencyAnalyzer
- Refactored code ==> Conversion of PluginDataProcessor into an abstract class where classes in need of its functions will extend from it.
- 2nd task work still in progress...



26th June, Friday
Tasks Completed:
- Conversion of PluginDataProcessor into PluginData abstract class complete.
- PluginDataObservable is extended from PluginData and is slightly more specialized towards task status displays
   ==> Since LoadStatusDisplay observes PluginListBuilder & XMLFileDownloader, these two latter classes can extend from PluginDataObservable instead
- DependencyAnalyzer now able to track timestamps of dependencies by refering to the prebuilt pluginList
   ==> Does NOT require XMLFileReader at all!
- More restructuring of code, added TODO notices for the possible future.
- PluginManager minor enhancements

Next week's tasks to focus on:
- Building of XML file
- Building of current.txt
- Uploading plugin updates, XML file, current.txt to server

Think small... hmmm.
