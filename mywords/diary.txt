4th May 2009, Monday

Tried out using Vi, and read up help pages for Git to familiarise with the technical terms.

This 4th May 2009 entry is modified after midnight to include the following:

How to stage change files for a commit ("git add", so as to track it for committing), how to commit changes ("git commit"), how to look at it using gitk (gitk master), how to push 'master' branch to pacific ("git push origin master"). May have "dry run" for commit through "git status", see which are the files changed - Do "git add" for relevant changes.

-commit name is a cryptographic hash (40-char hex string) of complete history up to that commit
-Files are identified by these cryptographic hashes, "object name"
-Directory stored as tree object - List of file/directory names
-Tree obj identified by hashes too
-"Git clone" assumed that you want to start working on the current branch
-"Git Remote Add" tells Git to track a remote repository, assuming you already have a current branch and do not need another one



5th May 2009, Tuesday

Its 11.37am now. What is going to happen today? Probably later going to start practising how to play with a bit of Git. But first I have to do some commits first so I can mess around in my own space. And I will create a new file listing project requirements.

When Git talks about a "clean state", working directory, index and HEAD (latest commit) agree fully

Git Reset
1) "git reset --soft" -> update HEAD, leave working directory and index alone
--> Implies slow way to say "git commit --amend" is to "git reset --soft HEAD^ && git commit"
2) "git reset --mixed" -> update HEAD, reset index, leave working directory alone
3) "git reset --hard" -> reset both index and working directory as well...

Git Rebase
e.g: git rebase -i HEAD~3

-"rebase" means to take a bunch of commits, and to try to apply the corresponding changes on top of another commit.
-With commit messages, authorship and all.
-"-i" says that it will be interactive, i.e. get to choose which commits to rebase, and in which order.
-"HEAD~3" rebase all commits descending from HEAD~3 (the great-grand-parent of HEAD) until HEAD.
-In a linear history (no merges), this means that you will rebase HEAD~2, HEAD~1 and HEAD.
-git rebase -i HEAD~3 will start text editor and present you with the list of commits to rebase.
-if you want to remove all three, you will have to add a command "noop" in the text editor.

Reverting commits and pushing local changes up...
With selected commits removed, "git push --force origin master". Need for the "--force" flag because system detects data would be lost on remote side, and by default prevents that.

Should you delete a file...
-You need it back, and its available in a previous commit
-"git checkout -- filename.txt" to get it from previous commit...
-"git checkout HEAD^^ -- filename.txt" to get file back from previous two commits...
-Note that "--" is an optional separator



6th May 2009, Wednesday
Used "git branch newbranch HEAD^^":
Basic Meaning: Create a new branch named "newbranch" with 2nd previous commit as HEAD (root node/latest commit).

Apparently, "^" means "previous". Commit IDs and tags may be used in place of "HEAD^^".

Different branches, different states:
Editing this diary from "master" branch, not "newbranch", so "newbranch" won't have these additions 

"git checkout newbranch" switches to "newbranch"
-Added "newbranch_doc.txt"
-File appears in "newbranch" but does not appear in "master"
-When it comes to switching branches, edits made must be committed first

Back at "master" branch, "git merge newbranch"
-Combine changes from both "master" and "newbranch"
-"master" now has both diary changes and "newbranch_doc.txt"

"git branch -d newbranch" deletes "newbranch"