.TH idlj 1  "23 Apr 2001"
.SH NAME
idlj \- IDL\-to\-Java compiler
.SH SYNOPSIS
.B idlj
[
.B options
]
.I idl\-file
.SH DESCRIPTION
The IDL\-to\-Java Compiler generates the Java bindings for a given IDL file. For binding details, see the 
.I "OMG IDL to Java Language Mapping Specification"
\. Some previous releases of the IDL\-to\-Java compiler were named \fBidltojava\fR.
.PP
In the synopsis, \fIidl\-file\fR is the name of a file containing Interface Definition Language (IDL) definitions. The \fIoptions\fR may appear in any order, but must precede the \fIidl\-file\fR.
.SS EMITTING\ CLIENT\ AND\ SERVER\ BINDINGS
To generate Java bindings for an IDL file named \fBMy.idl\fR:

.nf
   example% \fBidlj My.idl\fR
.fi
.PP
This generates the client\-side bindings and is equivalent to:

.nf
   example% \fBidlj \-fclient My.idl\fR
.fi
.PP
The client\-side bindings do not include the server\-side skeleton. If you want to generate the server\-side bindings for the interfaces:

.nf
   example% \fBidlj \-fserver My.idl\fR
.fi
.PP
Server\-side bindings include the client\-side bindings plus the skeleton, all of which are POA (that is, Inheritance Model) classes. If you want to generate both client and server\-side bindings, use one of the following (equivalent) commands:

.nf
   example% \fBidlj \-fclient \-fserver My.idl\fR
   example% \fBidlj \-fall My.idl\fR
.fi
.PP
There are two possible server\-side models: the Inheritance Model and the Tie Model.
.PP
.I "Inheritance Model"
.PP
A new feature in 1.4: The default server\-side model is the \fBPortable Servant Inheritance Model\fR. Given an interface \fBMy\fR defined in \fBMy.idl\fR, the file \fBMyPOA.java\fR is generated. You must provide the implementation for \fBMy\fR and it must inherit from \fBMyPOA\fR.
.PP
\fBMyPOA.java\fR is a stream\-based skeleton that extends \fBorg.omg.PortableServer.Servant\fR and implements the \fBInvokeHandler\fR interface and the operations interface associated with the IDL interface that the skeleton implements.
.PP
The \fBPortableServer\fR module for the Portable Object Adapter (POA) defines the native \fBServant\fR type. In the Java programming language, the \fBServant\fR type is mapped to the Java \fBorg.omg.PortableServer.Servant\fR class. It serves as the base class for all POA servant implementations and provides a number of methods that may be invoked by the application programmer, as well as methods which are invoked by the POA itself and may be overridden by the user to control aspects of servant behavior.
.PP
Another option for the Inheritance Model is to use the \fB\-oldImplBase\fR flag in order to generate server\-side bindings that are compatible with older version of the Java programming language (prior to J2SE 1.4). To generate server\-side bindings that are backwards compatible:

.nf
   example% \fBidlj \-fclient \-fserver \-oldImplBase My.idl\fR
   example% \fBidlj \-fall \-oldImplBase My.idl\fR
.fi
.PP
Given an interface \fBMy\fR defined in \fBMy.idl\fR, the file \fB_MyImplBase.java\fR is generated. You must provide the implementation for \fBMy\fR and it must inherit from \fB_MyImplBase\fR.
.PP
.I "Tie Model"
.PP
The other server\-side model is called the Tie Model. This is a delegation model. Because it is not possible to generate ties and skeletons at the same time, they must be generated separately. The following commands generate the bindings for the Tie Model:

.nf
   example% \fBidlj \-fall My.idl\fR
   example% \fBidlj \-fallTIE My.idl\fR
.fi
.PP
For the interface \fBMy\fR, the second command generates \fBMyPOATie.java\fR. The constructor to \fBMyPOATie\fR takes a \fBdelegate\fR. You must provide the implementation for \fBdelegate\fR, but it does not have to inherit from any other class, only the interface \fBMyOperations\fR. But to use it with the ORB, you must wrap your implementation within \fBMyPOATie\fR. For instance:

.nf
   MyImpl myImpl = new MyImpl ();
   MyPOATie tie = new MyPOATie (myImpl);
   orb.connect (tie);
.fi
.PP
You might want to use the Tie Model instead of the typical Inheritance Model if your implementation must inherit from some other implementation. Java allows any number of interface inheritance, but there is only one slot for class inheritance. If you use the Inheritance Model, that slot is used up. By using the Tie Model, that slot is freed up for your own use. The drawback is that it introduces a level of indirection, that is, one extra method call occurs when invoking a method.
.PP
To generate server\-side, Tie Model bindings that are compatible with older version of the IDL\(emto\-Java language mapping in versions of J2SE before 1.4:

.nf
   example% \fBidlj \-oldImplBase \-fall My.idl\fR
   example% \fBidlj \-oldImplBase \-fallTIE My.idl\fR
.fi
.PP
For the interface \fBMy\fR, this will generate \fBMy_Tie.java\fR. The constructor to \fBMy_Tie\fR takes an \fBimpl\fR. You must provide the implementation for \fBimpl\fR, but it does not have to inherit from any other class, only the interface \fBHelloOperations\fR. But to use it with the ORB, you must wrap your implementation within \fBMy_Tie\fR. For instance:

.nf
   MyImpl myImpl = new MyImpl (); 
   MyPOATie tie = new MyPOATie (myImpl); 
   orb.connect (tie);
.fi
.SS SPECIFYING\ ALTERNATE\ LOCATIONS\ FOR\ EMITTED\ FILES
If you want to direct the emitted files to a directory other than the current directory, invoke the compiler as:

.nf
   example% \fBidlj \-td /altdir My.idl\fR 
.fi
.PP
For the interface \fBMy\fR, the bindings will be emitted to \fB/altdir/My.java\fR, and so forth, instead of \fB./My.java\fR.
.SS SPECIFYING\ ALTERNATE\ LOCATIONS\ FOR\ INCLUDE\ FILES
If \fBMy.idl\fR included another idl file, \fBMyOther.idl\fR, the compiler assumes that \fBMyOther.idl\fR resides in the local directory. If it resides in \fB/includes\fR, for example, then you would invoke the compiler with the following command:

.nf
   example% \fBidlj \-i /includes My.idl\fR 
.fi
.PP
If \fBMy.idl\fR also included \fBAnother.idl\fR that resided in \fB/moreIncludes\fR, for example, then you would invoke the compiler with the following command:

.nf
   example% \fBidlj \-i /includes \-i /moreIncludes My.idl \fR
.fi
.PP
Since this form of include can become irritatingly long, another means of indicating to the compiler where to search for included files is provided. This technique is similar to the idea of an environment variable. Create a file named \fBidl.config\fR in a directory that is listed in your \fBCLASSPATH\fR. Inside of\fB idl.config\fR, provide a line with the following form:

.nf
   includes=/includes:/moreIncludes
.fi
.PP
The compiler will find this file and read in the includes list. Notice that in this example the separator character between the two directories is a colon (:). This separator character is platform dependent. On NT it is a semicolon, on Mac OS X it is a colon, and so forth. For more information on includes, read the \fBCLASSPATH\fR (Solaris), \fBCLASSPATH\fR (Linux), \fBCLASSPATH\fR (Windows) documentation.
.SS EMITTING\ BINDINGS\ FOR\ INCLUDE\ FILES
By default, only those interfaces, structs, and so on, that are defined in the idl file on the command line have Java bindings generated for them. The types defined in included files are not generated. For example, assume the following two idl files:

.nf
   \fIMy.idl\fR
      #include <MyOther.idl>
      interface My
      {
      };

   \fIMyOther.idl\fR
      interface MyOther
      {
      };
.fi

The following command will only generate the java bindings for \fBMy\fR:

.nf
   example% \fBidlj My.idl\fR
.fi
.PP
To generate all of the types in \fBMy.idl\fR and all of the types in the files that \fBMy.idl\fR includes (in this example, \fBMyOther.idl\fR), use the following command:

.nf
   example% \fBidlj \-emitAll My.idl\fR
.fi
.PP
There is a caveat to the default rule. \fB#include\fR statements which appear at global scope are treated as described. These \fB#include\fR statements can be thought of as import statements. \fB#include\fR statements which appear within some enclosing scope are treated as true \fB#include\fR statements. This means that the code within the included file is treated as if it appeared in the original file and, therefore, Java bindings are emitted for it. Here is an example:

.nf
   \fIMy.idl\fR
      #include <MyOther.idl> 
      interface My 
      { 
      #include <Embedded.idl> 
      };

   \fIMyOther.idl\fR
      interface MyOther 
      { 
      };

   \fIEmbedded.idl\fR
      enum E {one, two, three};
.fi

Running the following command:

.nf
   example% \fBidlj My.idl\fR
.fi

will generate the following list of Java files:

.nf
   ./MyHolder.java 
   ./MyHelper.java 
   ./_MyStub.java 
   ./MyPackage 
   ./MyPackage/EHolder.java 
   ./MyPackage/EHelper.java 
   ./MyPackage/E.java 
   ./My.java 

.fi
.PP
Notice that \fBMyOther.java\fR was not generated because it is defined in an import\-like \fB#include\fR. But \fBE.java\fR was generated because it was defined in a true \fB#include\fR. Also notice that since \fBEmbedded.idl\fR was included within the scope of the interface \fBMy\fR, it appears within the scope of \fBMy\fR (that is, in \fBMyPackage\fR).
.PP
If the \fB\-emitAll\fR flag had been used in the previous example, then all types in all included files would be emitted.
.SS INSERTING\ PACKAGE\ PREFIXES
Suppose that you work for a company named \fBABC\fR that has constructed the following IDL file:

.nf
   \fIWidgets.idl\fR
      module Widgets 
      { 
      interface W1 {...}; 
      interface W2 {...}; 
      };
.fi
.PP
Running this file through the IDL\-to\-Java compiler will place the Java bindings for \fBW1\fR and \fBW2\fR within the package \fBWidgets\fR. But there is an industry convention that states that a company's packages should reside within a package named \fBcom.\fR\fIcompany name\fR. The \fBWidgets\fR package is not good enough. To follow convention, it should be \fBcom.abc.Widgets\fR. To place this package prefix onto the \fBWidgets\fR module, execute the following:

.nf
   example% \fBidlj \-pkgPrefix Widgets com.abc Widgets.idl\fR 
.fi
.PP
If you have an IDL file which includes \fBWidgets.idl\fR the \fB\-pkgPrefix\fR flag must appear in that command also. If it does not, then your IDL file will be looking for a \fBWidgets\fR package rather than a \fBcom.abc.Widgets\fR package. If you have a number of these packages that require prefixes, it might be easier to place them into the \fBidl.config\fR file described above. Each package prefix line should be of the form:

.nf
   PkgPrefix.<type>=<prefix>
.fi
.PP
So the line for the above example would be:

.nf
   PkgPrefix.Widgets=com.abc 
.fi
.PP
The use of this option does not affect the Repository ID.
.SS DEFINING\ SYMBOLS\ BEFORE\ COMPILATION
You may need to define a symbol for compilation that is not defined within the IDL file, perhaps to include debugging code in the bindings. The command:

.nf
   example% \fBidlj \-d MYDEF My.idl\fR
.fi

is the equivalent of putting the line \fB#define MYDEF\fR inside \fBMy.idl\fR.
.SS PRESERVING\ PRE\-EXISTING\ BINDINGS
If the Java binding files already exist, the \fB\-keep\fR flag will keep the compiler from overwriting them. The default is to generate all files without considering if they already exist. If you've customized those files (which you should not do unless you are very comfortable with their contents), then the \fB\-keep\fR option is very useful. The command:

.nf

   example% \fBidlj \-keep My.idl\fR
.fi

emits all client\-side bindings that do not already exist.
.SS VIEWING\ PROGRESS\ OF\ COMPILATION
The IDL\-to\-Java compiler will generate status messages as it progresses through its phases of execution. Use the \fB\-v\fR option to activate this "verbose" mode:

.nf
   example% \fBidlj \-v My.idl\fR
.fi
.PP
By default, the compiler does not operate in verbose mode.
.SS DISPLAYING\ VERSION\ INFORMATION
To display the build version of the IDL\-to\-Java compiler, specify the \fB\-version\fR option on the command line:

.nf
   example% \fBidlj \-version\fR 
.fi
.SH OPTIONS
The following options are supported:
.TP 
\fB\-d\fR \fIsymbol\fR
This is equivalent to the following line in an IDL file:

.nf
   #define symbol
.fi
.TP 
\fB\-emitAll\fR 
Emits all types, including those found in \fB#include\fR files.
.TP 
\fB\-f\fR\fIside\fR 
Defines what bindings to emit. \fIside\fR is one of \fBclient\fR, \fBserver\fR, \fBserverTIE\fR, \fBall\fR, or \fBallTIE\fR. The \fB\-f\fR\fBserverTIE\fR and \fB\-f\fR\fBallTIE\fR options cause delegate model skeletons to be emitted. Assumes \fB\-f\fR\fBclient\fR if the flag is not specified.
.TP 
\fB\-i\fR \fIinclude\-path\fR 
By default, the current directory is scanned for included files. This option adds another directory. 
.TP 
\fB\-keep\fR
If a file to be generated already exists, does not overwrite it. By default it is overwritten.
.TP 
\fB\-noWarn\fR 
Suppresses warning messages.
.TP 
\fB\-oldImplBase\fR
Generates skeletons compatible with old (pre\-1.4) JDK ORBs. By default, the POA Inheritance Model server\-side bindings are generated. This option provides backward\-compatibility with older versions of the Java programming language by generating server\-side bindings that are \fBImplBase\fR Inheritance Model classes.
.TP 
\fB\-pkgPrefix\fR \fItype\fR \fIprefix\fR
Wherever \fItype\fR is encountered at file scope, prefixes the generated Java package name with \fIprefix\fR for all files generated for that type. The \fItype\fR is the simple name of either a top\-level module, or an IDL type defined outside of any module.
.TP 
\fB\-pkgTranslate\fR \fItype\fR \fIpackage\fR
Whenever the module name \fItype\fR is encountered in an identifier, this option replaces it in the identifier with \fIpackage\fR for all files in the generated Java package. Notice that \fB\-pkgPrefix\fR changes are made first. \fItype\fR is the simple name of either a top\-level module, or an IDL type defined outside of any module, and must match the full package name exactly.

If more than one translation matches an identifier, the longest match is chosen. For example, if the arguments include:

.nf
   example% \fB\-pkgTranslate foo bar \-pkgTranslate foo.baz buzz.fizz\fR
.fi

The following translations would occur:

.nf
   foo          => bar
   foo.boo      => bar.boo
   foo.baz      => buzz.fizz
   foo.baz.bar  => buzz.fizz.bar
.fi

The following package names cannot be translated:
.RS 
.TP 0.2i
\(bu
\fBorg\fR
.TP 0.2i
\(bu
\fBorg.omg\fR or any subpackages of \fBorg.omg\fR
.LP
Any attempt to translate these packages will result in uncompilable code, and the use of these packages as the first argument after \fB\-pkgTranslate\fR will be treated as an error.
.RE
.TP 
\fB\-skeletonName\fR \fIxxx%yyy\fR
Uses \fIxxx%yyy\fR as the pattern for naming the skeleton. The defaults are:
.RS 
.TP 0.2i
\(bu
\fB%POA\fR for the POA base class (\fB\-f\fR\fBserver\fR or \fB\-fall\fR).
.TP 0.2i
\(bu
\fB_%ImplBase\fR for the \fBoldImplBase\fR class (\fB\-oldImplBase\fR and either \fB\-f\fR\fBserver\fR or \fB\-fall\fR).
.RE
.TP 
\fB\-td\fR \fIdir\fR
Uses \fIdir\fR for the output directory instead of the current directory.
.TP 
\fB\-tieName\fR \fIxxx%yyy\fR
Uses \fIxxx%yyy\fR as the pattern for naming the tie. The defaults are:
.RS 
.TP 0.2i
\(bu
\fB%POATie\fR for the POA tie base class (\fB\-f\fR\fBserver\fR or \fB\-fallTie\fR).
.TP 0.2i
\(bu
\fB%_Tie\fR for the \fBoldImplBase\fR class (\fB\-oldImplBase\fR and either \fB\-f\fR\fBserverTie\fR or \fB\-fallTie\fR).
.RE
.TP 
\fB\-nowarn\fR, \fB\-verbose\fR 
Verbose mode.
.TP 
\fB\-version\fR
Displays version information and terminates.
.SH ENVIRONMENT\ VARIABLES
.TP 
\fBCLASSPATH\fR 
Used to provide the system with a path to user\-defined classes. Directories are separated by colons. For example: 

\fB\&.:/Users/vlh/classes:/Users/Shared/classes\fR 
.SH RESTRICTIONS
.TP 0.2i
\(bu
Escaped identifiers in the global scope may not have the same spelling as IDL primitive types, \fBObject\fR or \fBValueBase\fR. This is because the symbol table is pre\-loaded with these identifiers. Allowing them to be redefined would overwrite their original definitions. (Possible permanent restriction).
.TP 0.2i
\(bu
The fixed IDL type is not supported.
.SH SEE\ ALSO
.I "OMG IDL to Java Language Mapping Specification"
.SH BUGS
No import is generated for global identifiers. If you invoke on an unexported local \fBimpl\fR, you do get an exception, but it seems to be due to a Null Ptr Exception in the \fBServerDelegate\fR DSI code.